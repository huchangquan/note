(友情提示:以下内容请以二进制数来思考,并以怀疑的态度阅读)

常用数据类型和其大小

								   字节数				有符号					无符号
有符号			无符号			32位 	64位	最小值		最大值		最小值		最大值
[signed] char	unsigned char	1		1		(-2^7)		(2^7-1)		0			(2^8-1)
short			unsigned short	2		2		(-2^15)		(2^15-1)	0			(2^16-1)
int				unsigned int	4		4		(-2^31)		(2^31-1)	0			(2^32-1)
long			unsigned long 	4		8		(-2^31)		(2^31-1)	0			(2^64-1)
int32_t			uint32_t		4		4		(-2^31)		(2^31-1)	0			(2^32-1)
int64_t			uint64_t		8		8		(-2^63)		(2^63-1)	0			(2^64-1)
char *							4		8		(-2^31)		(2^31-1)	0			(2^64-1)
float							4		4		(-2^31)		(2^31-1)	0			(2^32-1)
double							8		8		(-2^63)		(2^63-1)	0			(2^64-1)

机器端序	(大端,小端)
	栗子： 0x12345678
		大端： 
			地址：		0x100	0x101	0x102	0x103
			值：		12		34		56		78
		小端：
			地址：		0x100	0x101	0x102	0x103
			值：		78		56		34		12

强制类型转换-->见 同级目录中的类型强制转换和端序.jpg

布尔代数
	布尔运算符 	~	&	|	^
		~0 = 1	1&0 = 0		0|0 = 0		0^0	= 0
		~1 = 0	1&1 = 1		0|1 = 1		0^1	= 1
				0&0 = 0		1|0 = 1		1^0	= 1
				0&1 = 0		1|1 = 1		1^1	= 0
			
	位级运算符	~	&	|	^
		同上
	
	逻辑运算符	!	&&	||
		!0 = 1	0&&0 = 0	0||0 = 0
		!1 = 0	0&&1 = 0	0||1 = 1
				1&&0 = 0	1||0 = 1
				1&&1 = 1	1||1 = 1

移位运算
	左移
		0110 1001 << 1 = 1101 0010
		
	逻辑右移
		0110 1001 >> 1 = 0011 0100
		
	算术右移  (前边补上最高位的值)		有利于有符号整数运算
		1.	0110 1001 >> 1 = 0011 0100
		2.	1110 1001 >> 1 = 1111 0100
		
编码格式 
	无符号整型
		1101   1*2^3 + 1*2^2 + 0*2^1 + 1*2^0 = 13
		
	补码  最高位的权值为负	负数表示方法
		1101   -1*2^3 + 1*2^2 + 0*2^1 + 1*2^0 = -3
		
	有符号数与无符号数的转换如上。	
	
	位扩展 (16位数 --> 32位数)
		无符号:	扩展位补0
		有符号:	扩展位补最高有效位
		
	位截断 (32位数 --> 16位数)
		简单的按剩下的低16位来重新计算数值
		
	无符号加法 (假设只能用4位保存数据)
		1001 + 1000 = 1 0001  最高位将会丢失
	
	=============================
	概念: 阿尔贝群   -x + x = 0  (求反就是这个意思)
	=============================
	无符号求反 (假设只能用4位保存数据4位)
		x(f) = 2^4 - x (x != 0)    这里是因为2^4 = 1 0000  是溢出的,  最后结果为 0
		
	补码加法 (假设只能用4位保存数据)
		1000 + 1000 = 1 0000	两个负数相加成正数   	负溢出
		0111 + 0111 = 1110		两个正数相加成负数		正溢出
	
	补码求反(补码非) (假设只能用4位保存数据)
		x(f) = -x (x != Min)
		
	无符号乘法和补码乘法  就是简单的溢出截断重新计算值(没溢出不算)
	
	乘法运算 (编译器通常会试图用移位和加法减法来替换乘法) (无符号和有符号相同)
		x*14  = x*(2^3 + 2^2 + 2^1) =  (x<<3)+(x<<3)+(x<<1)
		x*14  = x*(2^4 - 2^1) = (x<<4)-(x<<1)
		
	除法运算 (无符号:逻辑右移 有符号:算术右移) (这里指的是除以2的幂) (这里没有说除以任意的值)

IEEE浮点   
	V = (-1)^s * m * 2^e   (m由M计算得到,e由E计算得到)
		s: 符号位 负(1)  正(0)
		M: 尾数 这个值被解释为 (规格化) m = 1+M (非规格化) m = M	M指的是小数点右边部分
		E: 阶码	这个值被解释为 e = E-Bias    Bias(2^(k-1)-1) k:E的位数
		
	单精度 (float)		双精度 (double)
位	31 	30~23 	22~0	63	62~52	51~0
	s	E(8位)	M(23位)	s	E(11位)	M(52位)
	
	规格化 (单精度为例)
		E!=0 && E!=255
	
	非规格化 (单精度为例)
		除规格化外就是非规格化了
		E=255 && M=0  	表示无穷大
		E=255 && M!=0	表示NaN 不是一个值的意思.(个人理解)这里不是说不能表示值了,是被定义成这样的规则
		
舍入问题
	-5	-4	-3	-2	-1	0	1	2	3	4	5
	========================================== (我是一个尺子)
	1.向偶数舍入: 向靠的最近那个偶数的方向
	2.向零舍入:	向零的方向
	3.向下舍入:	向左边
	4.向上舍入:	向右边
		
浮点数表示的是相近值，不能完全精准表示每一个值,写程序时当需要用到超高精度时,请小心谨慎